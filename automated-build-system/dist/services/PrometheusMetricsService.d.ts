import { EventEmitter } from 'events';
export interface PrometheusConfig {
    enableDefaultMetrics: boolean;
    metricsPort: number;
    metricsPath: string;
    collectInterval: number;
    enableCustomMetrics: boolean;
    enableBuildMetrics: boolean;
    enableAssetMetrics: boolean;
    enablePartnerMetrics: boolean;
    enableSystemMetrics: boolean;
}
export declare class PrometheusMetricsService extends EventEmitter {
    private config;
    private server?;
    private isRunning;
    private buildCounter;
    private buildDuration;
    private buildStagesDuration;
    private activeBuildGauge;
    private buildQueueGauge;
    private buildErrorCounter;
    private assetProcessingCounter;
    private assetProcessingDuration;
    private assetSizeHistogram;
    private assetCompressionGauge;
    private assetQualityGauge;
    private partnerCounter;
    private partnerBuildCounter;
    private partnerUsageGauge;
    private partnerActiveGauge;
    private systemCpuGauge;
    private systemMemoryGauge;
    private systemDiskGauge;
    private systemNetworkCounter;
    private httpRequestCounter;
    private httpRequestDuration;
    private httpErrorCounter;
    private processingRateGauge;
    private throughputGauge;
    private errorRateGauge;
    constructor(config?: Partial<PrometheusConfig>);
    private initializeMetrics;
    start(): Promise<void>;
    stop(): Promise<void>;
    recordBuildStarted(partnerId: string, buildType?: string): void;
    recordBuildCompleted(partnerId: string, duration: number, buildType?: string): void;
    recordBuildFailed(partnerId: string, duration: number, buildType?: string): void;
    recordBuildStage(partnerId: string, stage: string, duration: number, buildType?: string): void;
    recordBuildError(partnerId: string, errorType: string, stage: string): void;
    updateBuildQueue(queueLength: number): void;
    recordAssetProcessed(partnerId: string, assetType: string, format: string, density?: string): void;
    recordAssetProcessingTime(assetType: string, format: string, duration: number): void;
    recordAssetSize(assetType: string, format: string, stage: 'original' | 'processed', sizeBytes: number): void;
    recordAssetCompression(assetType: string, format: string, compressionRatio: number): void;
    recordAssetQuality(assetType: string, format: string, qualityScore: number): void;
    recordPartnerRegistered(subscriptionTier: string, status?: string): void;
    recordPartnerBuild(partnerId: string, subscriptionTier: string): void;
    updatePartnerUsage(partnerId: string, resourceType: string, usagePercent: number): void;
    updateActivePartners(count: number): void;
    updateSystemCpu(usagePercent: number): void;
    updateSystemMemory(type: string, usageBytes: number): void;
    updateSystemDisk(mountPoint: string, type: string, usageBytes: number): void;
    recordNetworkTransfer(direction: 'in' | 'out', interfaceName: string, bytes: number): void;
    recordHttpRequest(method: string, route: string, statusCode: number, duration: number): void;
    recordHttpError(method: string, route: string, errorType: string): void;
    updateProcessingRate(type: string, ratePerMinute: number): void;
    updateThroughput(type: string, itemsPerSecond: number): void;
    updateErrorRate(type: string, errorRatePercent: number): void;
    getHttpMetricsMiddleware(): (req: any, res: any, next: any) => void;
    getMetricsJson(): Promise<any>;
    clearMetrics(): void;
    getRegistry(): import("prom-client").Registry<"text/plain; version=0.0.4; charset=utf-8">;
    isServerRunning(): boolean;
    getConfig(): PrometheusConfig;
}
export default PrometheusMetricsService;
//# sourceMappingURL=PrometheusMetricsService.d.ts.map